{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. 01_introduction.md # Introduction to Docker 02_containers.md # Introduction to containers 03_installation.md # Installing Docker and running a container","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. 01_introduction.md # Introduction to Docker 02_containers.md # Introduction to containers 03_installation.md # Installing Docker and running a container","title":"Project layout"},{"location":"01_introduction/","text":"1: Introduction Docker is a tool which allows users to build, share, package, verify, and run applications in isolated environments called containers while avoiding the tedium of environment confirguration and management. It's not uncommon when programming collaboratively that something that might work well on one user's environment will run into issues when another user tries to run the same steps. Docker ensures that applications and their dependencies are bundled together in a portable format, side-stepping the classic \"well, it works on my machine\" issue which can be otherwise difficult to solve. Whether developing from your personal laptop or deploying to production servers, Docker helps to ensure that the environment stays consistent. Containers are lightweight and fast, built to share the host's operating system's kernal rather than running full virtual machines. This makes them efficiently capable of isolating processses, testing software in clean environments, or managing complex multi-service applications without polluting your local system. In this lesson, we'll explore: What containers are and how they differ from virtual machines. How to install Docker and run your first container. How to install SSH inside a container, and why you might choose to do so. How to use basic Docker commands to build, inspect, and manage your containers. Practical examples to illustrate how Docker can simplify both development and deployment workflows. By the end of this lesson, you should have a working understanding of how to use Docker to create reliable and reproducible environments for your projects. Let's continue to section 2 to begin learning about container images and containers.","title":"1: Introduction"},{"location":"01_introduction/#1-introduction","text":"Docker is a tool which allows users to build, share, package, verify, and run applications in isolated environments called containers while avoiding the tedium of environment confirguration and management. It's not uncommon when programming collaboratively that something that might work well on one user's environment will run into issues when another user tries to run the same steps. Docker ensures that applications and their dependencies are bundled together in a portable format, side-stepping the classic \"well, it works on my machine\" issue which can be otherwise difficult to solve. Whether developing from your personal laptop or deploying to production servers, Docker helps to ensure that the environment stays consistent. Containers are lightweight and fast, built to share the host's operating system's kernal rather than running full virtual machines. This makes them efficiently capable of isolating processses, testing software in clean environments, or managing complex multi-service applications without polluting your local system. In this lesson, we'll explore: What containers are and how they differ from virtual machines. How to install Docker and run your first container. How to install SSH inside a container, and why you might choose to do so. How to use basic Docker commands to build, inspect, and manage your containers. Practical examples to illustrate how Docker can simplify both development and deployment workflows. By the end of this lesson, you should have a working understanding of how to use Docker to create reliable and reproducible environments for your projects. Let's continue to section 2 to begin learning about container images and containers.","title":"1: Introduction"},{"location":"02_containers/","text":"2: Containers and Images When working with Docker, two core concepts that you'll encounter are container images and containers . Understanding them both and the distinctions between them is key to the effective use of Docker. 2.1: Container Images A container image can be likened to a packaged blueprint of a container, including everything that a program requires to run such as the code of the application itself, the required system libraries and dependencies, the configuration files and environment settings, etc. Container images are static and read-only - you can think of them as snapshots or templates. Once built, they can be stored, shared, and reused on any system that supports Docker. Docker images are versioned and portable, allowing you to move seamlessly between development, testing, and production environments. 2.2: Containers Docker describes containers as \"a standard unit of software\" which packages all code and its dependencies. It can also be thought of as a running instance of a container image. When Docker starts a container, it creates a writable layer \"on top\" of the read-only image, before allowing the application to run in an isolated environment with its own file system, network interfaces, and process space. You can run multiple containers from the same image at the same time while allowing each container to act as an independent unit. For example, it might be useful to use the same database image to run one container for development, another for automated tests, and a third in production. Despite all coming from the same image, each container is able to store its own data and settings. This separation between images (the blueprints) and containers (the running instances) allows Docker to quickly set up new environments, efficiently reuse resources, and ensure consistency across machines and stages of development. 2.3: Containers vs. Virtual Machines While containers and virtual machines (VMs) might seem similar at a glance (both allow you to run isolated environments), the way that they achieve their isolation and their performance characteristics are significantly different. A virtual machine emulates an entire computer , including: * Its own guest operating system. * Virtual hardware, such as CPU, memory, disk, and network interfaces. Each VM runs on top of a hypervisor, such as VirtualBox or VMware, which sits between the physical hardware and the virtual machine. As mentioned before, a container shares the host's operating system kernal, simply isolating the file system, processes, and network. To summarize: Feature Virtual Machine Container OS: Full OS per VM Shares host OS kernel Startup Time: Minutes Seconds Resource Usage: Heavy (GBs of disk space, RAM intensive) Light (MBs to low GBs) Isolation: Hardware-level Process-level Let's continue on to section 3 to install Docker and start working with containers.","title":"2: Containers and Images"},{"location":"02_containers/#2-containers-and-images","text":"When working with Docker, two core concepts that you'll encounter are container images and containers . Understanding them both and the distinctions between them is key to the effective use of Docker.","title":"2: Containers and Images"},{"location":"02_containers/#21-container-images","text":"A container image can be likened to a packaged blueprint of a container, including everything that a program requires to run such as the code of the application itself, the required system libraries and dependencies, the configuration files and environment settings, etc. Container images are static and read-only - you can think of them as snapshots or templates. Once built, they can be stored, shared, and reused on any system that supports Docker. Docker images are versioned and portable, allowing you to move seamlessly between development, testing, and production environments.","title":"2.1: Container Images"},{"location":"02_containers/#22-containers","text":"Docker describes containers as \"a standard unit of software\" which packages all code and its dependencies. It can also be thought of as a running instance of a container image. When Docker starts a container, it creates a writable layer \"on top\" of the read-only image, before allowing the application to run in an isolated environment with its own file system, network interfaces, and process space. You can run multiple containers from the same image at the same time while allowing each container to act as an independent unit. For example, it might be useful to use the same database image to run one container for development, another for automated tests, and a third in production. Despite all coming from the same image, each container is able to store its own data and settings. This separation between images (the blueprints) and containers (the running instances) allows Docker to quickly set up new environments, efficiently reuse resources, and ensure consistency across machines and stages of development.","title":"2.2: Containers"},{"location":"02_containers/#23-containers-vs-virtual-machines","text":"While containers and virtual machines (VMs) might seem similar at a glance (both allow you to run isolated environments), the way that they achieve their isolation and their performance characteristics are significantly different. A virtual machine emulates an entire computer , including: * Its own guest operating system. * Virtual hardware, such as CPU, memory, disk, and network interfaces. Each VM runs on top of a hypervisor, such as VirtualBox or VMware, which sits between the physical hardware and the virtual machine. As mentioned before, a container shares the host's operating system kernal, simply isolating the file system, processes, and network. To summarize: Feature Virtual Machine Container OS: Full OS per VM Shares host OS kernel Startup Time: Minutes Seconds Resource Usage: Heavy (GBs of disk space, RAM intensive) Light (MBs to low GBs) Isolation: Hardware-level Process-level Let's continue on to section 3 to install Docker and start working with containers.","title":"2.3: Containers vs. Virtual Machines"},{"location":"03_installation/","text":"3: Installing Docker","title":"3: Installing Docker"},{"location":"03_installation/#3-installing-docker","text":"","title":"3: Installing Docker"}]}